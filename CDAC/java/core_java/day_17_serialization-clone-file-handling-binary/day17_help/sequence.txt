Revise I/O
try (BR br=new BR(new FR(fileName)) {
  br.lines() 
  .forEach(s -> sop(s));
} catch - all

Copy files

try (BR br=new BR(new FR(srcFileName);
PW pw=new PW(new FW(destFile)) {
  br.lines() 
  .forEach(s -> pw.println(s));
} catch - all

Solve 
Customer details are present in the Map - customerMap : HashMap
sort them as per dob n store these sorted details in text file , using buffer

try(PW pw=new PW(new FW(fileName)){
  //customerMap
  Comparator<Customer> comp=(c1,c2) -> c1.getDob().compareTo(c2.getDob());
  customerMap.values() 
  .stream()
  .sorted(comp) 
  .forEach(c -> pw.println(c));
} //pw.close -> flush  -> closes the pw ,closes fw , closes sc
 catch-all


Regarding - java.io.File
- A class representing abstract path to a file or a folder.
Constructor
public File(String path)
Methods for checking
public boolean exists()
public boolean isFile()
public boolean canRead()

Solve - Store the product details , in a portable , machine independdent (binary) manner in a file.- buffered 
Instead of performing the conversions (from primitive types or strings  -> binary) , use readily available conversion streams

java.io.DataOutputStream - class
- Represents mixed data conversion stream
- Contains the methods for conversions
- from primitive types or strings  -> binary
- implements DataOutput i/f

Constructor
DataOutputStream(OutputStream out)
Methods -
public void writeInt(int i) throws IOException
public void writeDouble(double i) throws IOException
public void writeLong(long i) throws IOException
...
+
public void writeUTF(String s) throws IOException

Solve - Restore the same.
API -
java.io.DataInputStream - class
- Represents mixed data stream , to convert from binary -> prim types or strings
-implements DataInput i/f
-Ctor
public DataInputStream(InputStream in)
Methods 
public int readInt() throws IOException
public long readLong() throws IOException
public float readFloat() throws IOException
public String readUTF() throws IOException
.........

What is the need of Object Streams in Java ?  - automatic persistence
 
W/o these , a developer has to use Data I/O streams n convert each data member to binary using writeInt / readInt , writeUTF/readUTF etc.....

API - 
java.io.ObjectOutputStream - class
implements - DataOutput , ObjectOutput
Ctor

public ObjectOutputStream(OutputStream out) throws IOException
- Creates OOS instance , wrapping the bin o/p stream
eg - To store data in a bin file
OOS out=new OOS(new FOS(fileName));
Methods 
public void writeInt(int i) throws IOException
writeBoolean , writeUTF ....
+
public void writeObject(Object o) throws IOException , NotSerializableException

Serialization = Conversion from the object -> binary
What exactly is converted ? 
state of the object
State = non static & non transient data members.

What happens during Serialization - 
JVM checks the serializability of entire object graph.
Any time it comes across a non serializable object - abort the process n throws 
-java.io.NotSerializableException.

It's completely based upon reflection.

JVM checks if the class of the object has implemented - java.io.Serializable i/f
If yes - allows the conversion , otherwise throws the exception.


java.io.Serializable - Marker | Tag or empty i/f
i.e doesn't contain any data or methods.

It provides the job - run time marker (i.e informs the JVM to allow or not to allow the serialization)


De-Serialization 
API - ObjectInputStream - class
- implements DataInput , ObjectInput
Ctor
public ObjectInputStream(InputStream in)
-Performs de- serialization
Methods 
public int readInt() throws IOException
public double readDouble() throws IOException
public String readUTF() throws IOException
...
+
public Object readObject() throws 
ClassNotFoundException - if JVM's classloader can't find the required class
InvalidClassException - in case of mismatch in the SerialVersionUID (between the computed and received from bin stream)
IOException - in case of error in reading.
 
de-serialization=restoring the object/s from binary stream

What are the pre requisites of de-serialization?
1. state (retrieved from bin stream - file)
2. behavior (.class files - typically distributed in JAR file format)


What is SerialVersionUID ?
It's a public static long no , generated by IDE using serialversion tool.
(serialver.exe)

It is computed based upon  the metadata of the class
eg - access specifiers , data members etc.

JVM adds this SerialVerUID in the bin stream , during serialization (per every serializable class)

JVM re computes this serial ver UID during de-serial n matches it with the incoming one.
The main purpose is to check the compatibility of the classes used during ser n de-serial.

transient - keyword in java .
Applicable to data members(field)
Meaning - It's a keyword meant for JVM , to skip(ignore) a field during ser.


During de-ser - static as well as transient members - are initialized to the default values.

Use case - to store partial state of the serializable java object.


What is the recommended practice for generating serial ver UID ?
Choose default serial ver UID  or generated serial ver UID ?
Ans - choose default serial ver UID 
(eg 1L or 2L - programmer supplied - as per the class versions)

- to avoid compiler mismatches , across different JDK vendors - suggestion is you should generate UID n use.
It is then you responsibility to manage the changes in classes.


Cloning 
- to create clone of the original object.
API 
Object class method 
protected Object clone() throws CloneNotSupportedException

What will happen , if you directly use
Emp e=new Emp(....);
Obejct clonedEmp=e.clone();
--JVM  throws CloneNotSupportedException

Rule - The class MUST implement a marker i/f - java.lang.Cloneable
(empty i/f) , to allow cloning of the object.

Typically 
-override clone method , in your class
- Apply co variance (narrowing from the super type) , to avoid later down casting
- widen the access specifier from protected to public , so that clone() method can be called from anywhere.

eg - In Emp class - 
@Override
public Emp clone() throws CloneNotSupportedException
{
 (Emp)super.clone();
}
By default - creates field by field copy (shallow copy)

For deep copy , programmer has to clone the entire object graph.




 




























































Enter Binary streams
Serialization - de serialization
Method reference
Cloning 
Reflection overview
Enter Multi threading in Java 